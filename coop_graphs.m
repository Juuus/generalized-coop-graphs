function [pt, yt, arg] = coop_graphs(A,b,c,r,p0,Y0,T,D)
%% Promoting cooperation by preventing exploitation: The role of network structure

% This is a sample code for the implementation of the model for emergence of
%  cooperation described in
%  https://arxiv.org/pdf/1703.05951.pdf

%% Input arguments
% A - adjacency matrix;
% b - benefit;
% c - cost;
% r - memory rate.

%% Optional input arguments
% p0 - Nx1 vector of initial probabilities for cooperation. If not provided
%      p0 is a vector of ones multiplied by 0.05;
% Y0 - Nx1 vector of initial accumulated payoff. If not provided
%      Y0 is a vector of ones multiplied by -4;
% T  - time duration. If not provided T = 10^4;
% D -  number of unconditional defectors that are uniformly distributed among 
%      the nodes. If not provided D = 0.

% Note: For skipping a particular optional argument (or a group of optional arguments)
%       simply write [] in its (their) place.

%% Output

% pt.stochastic - TxN vector of cooperation probabilities estimated by the
%                 stochastic model.
% pt.deterministic - TxN vector of cooperation probabilities estimated by the
%                 deterministic model.
%                 In both cases, the (t,i)-th entry gives the
%                 probability for cooperation by node i in period t.
% yt.stochastic - TxN vector of payoffs estimated by the
%                 stochastic model.
% yt.deterministic - TxN vector of payoffs estimated by the
%                 deterministic model.
%                 In both cases, the (t,i)-th entry gives the
%                 payoff generated by node i in period t.
% arg           - a structure file containing the input and optional
%                 arguments
% Also plots a figure with the average probability for cooperation and
% payoff over time

N = size(A,1); % number of nodes
if ~exist('T','var') || isempty(T)
T = 10^4;   % total time
end

if ~exist('p0','var') || isempty(p0)
p0 = 0.05 * ones(N,1);   % initial probability
end

if ~exist('Y0','var') || isempty(Y0)
Y0 = -4 * ones(N,1);   % initial accumulated payoff
end

if ~exist('D','var') || isempty(D)
D = 0;   % initial accumulated payoff
else
 k = randperm(N,D)'; %set unconditional defectors
 p0(k)=0; 
end

u = 1; % probability of update

x =  zeros(N,1);
p = p0;
Y = Y0;

%% Logistic curve parameters %%

mi = 0; % midpoint of the curve
s = 1; % steepness of the curve
L = 1; % maximum value of the curve


%% Stochastic %%
pt.stochastic = zeros(T,N);
yt.stochastic = zeros(T,N);

for t = 1 :T

    H = zeros(N);   % H_ij = 1 indicates that i asks help from j
    
    for i = 1:N
        
       z = find(A(i,:))';   % see neighbours
        
       j = z(randi(size(z,1))); % randomly ask a neighbour
       
       H(i,j) = 1;
       
       x(i,:) = binornd(1,p(i));
    end
    
    d=sum(H,1);  % # of people who want help from i
    Dmat=zeros(N);
    
    for i = 1:N
    Dmat(i,i)=d(1,i);  % Helper in-degree matrix
    end
    
    y = (b * H - c * Dmat) * x ; % pay off
    
    Y = Y * r + y; % cumulative pay off
    
    for i = 1:N
        lambda = binornd(1,u);
        
       if lambda == 1
           p(i,1) = L/(1 + exp(-(s * (Y(i,1) - mi))));  % probability in t+1
           
       end
    end
    
     if D > 0 % make p = 0 for unconditional defectors
        p(k,1) = 0;
     end
   
    pt.stochastic(t,:) = transpose(p);
    yt.stochastic(t,:) = transpose(y);
  % disp(t)
        
end

%% Deterministic %%

pt.deterministic = zeros(T,N);
yt.deterministic = zeros(T,N);

p = p0;
Y = Y0;

degrees = sum(A,2);
H = zeros(N);   % random walk matrix



for i = 1:N
    
    H(i,:) = A(i,:)/degrees(i,1);
    
end


 d=sum(H,1);  % # of people who want help from i
 Dmat=zeros(N);
    
    for i = 1:N
    Dmat(i,i)=d(1,i);  % Helper in-degree matrix
    end

    
    
for t = 1 : T
    x = p ;

       
    y = (b * H - c * Dmat) * x; % pay off
    
    Y = Y * r + y; % cumulative pay off
    
    for i = 1:N
        
           F = (L/(1 + exp(-(s * (Y(i,1) - mi)))))^u;  
           
           p(i,1) = F * (p(i,1)^(1-u));

    end
    
     if D > 0 % make p = 0 for unconditional defectors
        p(k,1) = 0;
     end
   
    pt.deterministic(t,:) = transpose(p);
    yt.deterministic(t,:) = transpose(y);
end

%% Input arguments variable
    arg.A = A; arg.b = b; arg.c = c;
    arg.r = r; arg.p0 = p0; arg.Y0 = Y0;
    arg.T = T; arg.D = D;
    
    %% PLOT RESULTS %%

subplot(2,1,1)
plot(mean(pt.stochastic,2),'k','LineWidth',2)
hold on
plot(mean(pt.deterministic,2),'b','LineWidth',2)
ylim([0, 1.05]);
xlim([0, T+1]);
xlabel('$t$','Interpreter','latex')
ylabel('$\langle p(t) \rangle$','Interpreter','latex')
title('(a)', 'Units', 'normalized', ...
'Position', [0 1.05], 'HorizontalAlignment', 'right','Interpreter','latex')
set(gca,'TickLabelInterpreter','latex')
leg = legend('stochastic', 'deterministic');
set(leg, 'location','southeast')
set(leg, 'Interpreter','Latex')


subplot(2,1,2)
plot(mean(yt.stochastic,2),'k','LineWidth',2)
hold on
plot(mean(yt.deterministic,2),'r','LineWidth',2)
ylim([-c, b]);
xlim([0, T+1]);
xlabel('t','Interpreter','latex')
ylabel('$\langle y(t) \rangle$','Interpreter','latex')
title('(b)', 'Units', 'normalized', ...
'Position', [0 1.05], 'HorizontalAlignment', 'right','Interpreter','latex')
set(gca,'TickLabelInterpreter','latex')
leg = legend('stochastic', 'deterministic');
set(leg, 'location','southeast')
set(leg, 'Interpreter','Latex')
    
